#include "amftest.hpp"

#include "amf.hpp"
#include "types/amfbool.hpp"
#include "types/amfdouble.hpp"
#include "types/amfinteger.hpp"

static void isEqual(const std::vector<u8>& expected, int value) {
	isEqual(expected, AmfInteger(value));
}

TEST(IntegerSerialization, PositiveInteger1Byte) {
	isEqual(v8 { 0x04, 0x00 }, 0);
	isEqual(v8 { 0x04, 0x01 }, 1);
	isEqual(v8 { 0x04, 0x7E }, 0x7e);
	isEqual(v8 { 0x04, 0x7F }, 0x7f);
}

TEST(IntegerSerialization, PositiveInteger2Byte) {
	isEqual(v8 { 0x04, 0x81, 0x00 }, 0x80);
	isEqual(v8 { 0x04, 0x87, 0x7E }, 0x3fe);
	isEqual(v8 { 0x04, 0x87, 0x7F }, 0x3ff);
	isEqual(v8 { 0x04, 0x88, 0x00 }, 0x400);
}

TEST(IntegerSerialization, PositiveInteger3Byte) {
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0x7E }, 0x1ffffe);
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0x7F }, 0x1fffff);
}

TEST(IntegerSerialization, PositiveInteger4Byte) {
	isEqual(v8 { 0x04, 0x80, 0xC0, 0x80, 0x00 }, 0x200000);
	isEqual(v8 { 0x04, 0xBF, 0xFF, 0xFF, 0xFE }, 0xffffffe);
	isEqual(v8 { 0x04, 0xBF, 0xFF, 0xFF, 0xFF }, 0xfffffff);
}

TEST(IntegerSerialization, LargePositiveIntegerAsDouble) {
	isEqual(v8 { 0x05, 0x41, 0xBF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00 }, 0x1ffffffe);
	isEqual(v8 { 0x05, 0x41, 0xBF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00 }, 0x1fffffff);
	isEqual(v8 { 0x05, 0x41, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x20000000);
	isEqual(v8 { 0x05, 0x41, 0xDF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00 }, 0x7ffffffe);
	isEqual(v8 { 0x05, 0x41, 0xDF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00 }, 0x7fffffff);
	isEqual(v8 { 0x05, 0x41, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x10000000);
}

TEST(IntegerSerialization, NegativeInteger) {
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0xFF, 0xFF }, -1);
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0xFF, 0xFE }, -2);
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0xFF, 0xFD }, -3);
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0xFF, 0xFC }, -4);
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0xFF, 0xF9 }, -7);
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0xFF, 0xF8 }, -8);
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0xFF, 0xE1 }, -31);
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0xFF, 0xE0 }, -32);
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0xFF, 0x81 }, -127);
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0xFF, 0x80 }, -128);
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0xFF, 0x7F }, -129);
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0xC0, 0x01 }, -16383);
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0xC0, 0x00 }, -16384);
	isEqual(v8 { 0x04, 0xFF, 0xFF, 0xBF, 0xFF }, -16385);
	isEqual(v8 { 0x04, 0xFF, 0xC0, 0x80, 0x01 }, -2097151);
	isEqual(v8 { 0x04, 0xFF, 0xC0, 0x80, 0x00 }, -2097152);
	isEqual(v8 { 0x04, 0xFF, 0xBF, 0xFF, 0xFF }, -2097153);
	isEqual(v8 { 0x04, 0xC0, 0x80, 0x80, 0x01 }, -268435455);
	isEqual(v8 { 0x04, 0xC0, 0x80, 0x80, 0x00 }, -268435456);
}

TEST(IntegerSerialization, LargeNegativeIntegerAsDouble) {
	isEqual(v8 { 0x05, 0xC1, 0xB0, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 }, -268435457);
	isEqual(v8 { 0x05, 0xC1, 0xDC, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00 }, -1879048193);
	isEqual(v8 { 0x05, 0xC1, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, -2147483647 - 1);
}

TEST(IntegerAsLength, SimpleValue) {
	isEqual(v8 { 0x05, 0x07 }, AmfInteger::asLength(3, 0x05));
	isEqual(v8 { 0x06, 0x07 }, AmfInteger::asLength(3, 0x06));
	isEqual(v8 { 0x01, 0x87, 0x7F }, AmfInteger::asLength(511, 0x01));
}

TEST(IntegerAsLength, ValueRange) {
	// Lengths are serialized as U29, where 1 bit is the sign bit and 1 bit is
	// used as non-reference marker, which leaves us 27 bits for the actual value.
	// This test checks that only values that can actually be serialized to an U29
	// are accepted.
	ASSERT_THROW(AmfInteger::asLength(1 << 27, 0x01), std::invalid_argument);
	ASSERT_NO_THROW(AmfInteger::asLength((1 << 27) - 1, 0x01));

	isEqual(v8 { 0x0C, 0xBF, 0xFF, 0xFF, 0xFF }, AmfInteger::asLength((1 << 27) - 1, 0x0C));
}

TEST(IntegerEquality, SimpleValues) {
	AmfInteger i1(0);
	AmfInteger i2(1);
	AmfInteger i3(0x7e);
	AmfInteger i4(0x80);
	AmfInteger i5(0x1fffff);
	AmfInteger i6(0x200000);
	AmfInteger i7(0xfffffff);
	AmfInteger i8(-1);
	AmfInteger i9(-268435456);
	AmfInteger i10(0);
	AmfInteger i11(1);
	AmfInteger i12(-1);

	EXPECT_EQ(i1, i1);
	EXPECT_EQ(i2, i2);
	EXPECT_EQ(i3, i3);
	EXPECT_EQ(i4, i4);
	EXPECT_EQ(i5, i5);
	EXPECT_EQ(i6, i6);
	EXPECT_EQ(i7, i7);
	EXPECT_EQ(i8, i8);
	EXPECT_EQ(i9, i9);

	EXPECT_EQ(i1, i10);
	EXPECT_EQ(i2, i11);
	EXPECT_EQ(i8, i12);

	EXPECT_NE(i1, i8);
}

TEST(IntegerEquality, LargeValues) {
	AmfInteger i1(0x7fffffff);
	AmfInteger i2(0x7fffffff);
	AmfInteger i3(-2147483647);
	AmfInteger i4(-2147483647);
	AmfInteger i5(-2147483647 - 1);
	AmfInteger i6(-2147483647 - 1);

	EXPECT_EQ(i1, i1);
	EXPECT_EQ(i1, i2);
	EXPECT_EQ(i3, i4);
	EXPECT_EQ(i5, i6);

	EXPECT_NE(i1, i3);
}

TEST(IntegerEquality, MixedTypes) {
	AmfInteger i1(0);
	AmfDouble d(0);
	EXPECT_NE(i1, d);

	AmfBool b(false);
	EXPECT_NE(i1, b);
}

TEST(IntegerEquality, ImplicitConversion) {
	AmfInteger i1(1);
	EXPECT_EQ(i1, 1);

	AmfInteger i2(-1);
	EXPECT_EQ(i2, -1);

	AmfInteger i3(-2147483647 - 1);
	EXPECT_EQ(i3, -2147483647 - 1);
}

static void deserializesTo(int expected, const v8& data, int left = 0) {
	deserialize(AmfInteger(expected), data, left);
}

TEST(IntegerDeserialization, PositiveInteger1Byte) {
	deserializesTo(0, { 0x04, 0x00 });
	deserializesTo(1, { 0x04, 0x01 });
	deserializesTo(0x7E, { 0x04, 0x7E });
	deserializesTo(0x7F, { 0x04, 0x7F });
}

TEST(IntegerDeserialization, PositiveInteger2Byte) {
	deserializesTo(0x80, { 0x04, 0x81, 0x00 });
	deserializesTo(0x3fe, { 0x04, 0x87, 0x7E });
	deserializesTo(0x3ff, { 0x04, 0x87, 0x7F });
	deserializesTo(0x400, { 0x04, 0x88, 0x00 });
}

TEST(IntegerDeserialization, PositiveInteger3Byte) {
	deserializesTo(0x1ffffe, { 0x04, 0xFF, 0xFF, 0x7E });
	deserializesTo(0x1fffff, { 0x04, 0xFF, 0xFF, 0x7F });
}

TEST(IntegerDeserialization, PositiveInteger4Byte) {
	deserializesTo(0x200000, { 0x04, 0x80, 0xC0, 0x80, 0x00 });
	deserializesTo(0xffffffe, { 0x04, 0xBF, 0xFF, 0xFF, 0xFE });
	deserializesTo(0xfffffff, { 0x04, 0xBF, 0xFF, 0xFF, 0xFF });
}

TEST(IntegerDeserialization, NegativeInteger) {
	deserializesTo(-1, { 0x04, 0xFF, 0xFF, 0xFF, 0xFF });
	deserializesTo(-2, { 0x04, 0xFF, 0xFF, 0xFF, 0xFE });
	deserializesTo(-3, { 0x04, 0xFF, 0xFF, 0xFF, 0xFD });
	deserializesTo(-4, { 0x04, 0xFF, 0xFF, 0xFF, 0xFC });
	deserializesTo(-7, { 0x04, 0xFF, 0xFF, 0xFF, 0xF9 });
	deserializesTo(-8, { 0x04, 0xFF, 0xFF, 0xFF, 0xF8 });
	deserializesTo(-31, { 0x04, 0xFF, 0xFF, 0xFF, 0xE1 });
	deserializesTo(-32, { 0x04, 0xFF, 0xFF, 0xFF, 0xE0 });
	deserializesTo(-127, { 0x04, 0xFF, 0xFF, 0xFF, 0x81 });
	deserializesTo(-128, { 0x04, 0xFF, 0xFF, 0xFF, 0x80 });
	deserializesTo(-129, { 0x04, 0xFF, 0xFF, 0xFF, 0x7F });
	deserializesTo(-16383, { 0x04, 0xFF, 0xFF, 0xC0, 0x01 });
	deserializesTo(-16384, { 0x04, 0xFF, 0xFF, 0xC0, 0x00 });
	deserializesTo(-16385, { 0x04, 0xFF, 0xFF, 0xBF, 0xFF });
	deserializesTo(-2097151, { 0x04, 0xFF, 0xC0, 0x80, 0x01 });
	deserializesTo(-2097152, { 0x04, 0xFF, 0xC0, 0x80, 0x00 });
	deserializesTo(-2097153, { 0x04, 0xFF, 0xBF, 0xFF, 0xFF });
	deserializesTo(-268435455, { 0x04, 0xC0, 0x80, 0x80, 0x01 });
	deserializesTo(-268435456, { 0x04, 0xC0, 0x80, 0x80, 0x00 });
}

TEST(IntegerDeserialization, BytesLeft) {
	deserializesTo(0, { 0x04, 0x00, 0x00 }, 1);
	deserializesTo(1, { 0x04, 0x01, 0x00 }, 1);
	deserializesTo(0x3ff, { 0x04, 0x87, 0x7F, 0x7F }, 1);
	deserializesTo(0x3ff, { 0x04, 0x87, 0x7F, 0x7F, 0x00 }, 2);
	deserializesTo(0x1fffff, { 0x04, 0xFF, 0xFF, 0x7F, 0xFF }, 1);
	deserializesTo(0xffffffe, { 0x04, 0xBF, 0xFF, 0xFF, 0xFE, 0xFF }, 1);
	deserializesTo(-1, { 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0x00 }, 1);
}

TEST(IntegerDeserialization, NotEnoughBytes) {
	SerializationContext ctx;

	v8 data = { 0x04 };
	auto it = data.cbegin();
	ASSERT_THROW(AmfInteger::deserialize(it, data.cend(), ctx), std::out_of_range);

	data = { 0x04, 0x80 };
	it = data.cbegin();
	ASSERT_THROW(AmfInteger::deserialize(it, data.cend(), ctx), std::out_of_range);

	data = { 0x04, 0x80, 0x80 };
	it = data.cbegin();
	ASSERT_THROW(AmfInteger::deserialize(it, data.cend(), ctx), std::out_of_range);

	data = { 0x04, 0x80, 0x81, 0x82 };
	it = data.cbegin();
	ASSERT_THROW(AmfInteger::deserialize(it, data.cend(), ctx), std::out_of_range);

	data = { 0x04, 0x80, 0x81, 0x82, 0x83 };
	it = data.cbegin();
	ASSERT_NO_THROW(AmfInteger::deserialize(it, data.cend(), ctx));
}
