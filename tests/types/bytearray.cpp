#include "amftest.hpp"

#include <array>

#include "amf.hpp"
#include "types/amfarray.hpp"
#include "types/amfbytearray.hpp"
#include "types/amfinteger.hpp"
#include "types/amfvector.hpp"

TEST(ByteArraySerialization, SimpleValues) {
	AmfByteArray ba(v8 {1, 2, 3});
	isEqual({0x0c, 0x07, 0x01, 0x02, 0x03}, ba);

	ba = AmfByteArray(v8 { 0xff, 0xff, 0xff, 0xff });
	isEqual({0x0c, 0x09, 0xff, 0xff, 0xff, 0xff}, ba);
}

TEST(ByteArraySerialization, MultiByteLengthMarker) {
	v8 values(300, 0xde);
	v8 expected = {
		0x0c, 0x84, 0x59,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde
	};
	isEqual(expected, AmfByteArray(values));
}

TEST(ByteArraySerialization, ExplicitCArrayCtor) {
	u8 values[] = {1, 2, 3};
	isEqual({0x0c, 0x07, 0x01, 0x02, 0x03}, AmfByteArray(values));
}

TEST(ByteArraySerialization, ExplicitStdArrayCtor) {
	std::array<u8, 3> values = {{1, 2, 3}};
	isEqual({0x0c, 0x07, 0x01, 0x02, 0x03}, AmfByteArray(values));
}

TEST(ByteArraySerialization, ExplicitVectorCtor) {
	v8 values = {1, 2, 3};
	isEqual({0x0c, 0x07, 0x01, 0x02, 0x03}, AmfByteArray(values));
}

TEST(ByteArraySerialization, ObjectReferences) {
	SerializationContext ctx;
	isEqual({0x0c, 0x07, 0x01, 0x02, 0x03}, AmfByteArray {v8 {1, 2, 3}}, &ctx);
	isEqual({0x0c, 0x00}, AmfByteArray {v8 {1, 2, 3}}, &ctx);
	isEqual({0x0c, 0x07, 0x04, 0x05, 0x06}, AmfByteArray {v8 {4, 5, 6}}, &ctx);
	isEqual({0x0c, 0x00}, AmfByteArray {v8 {1, 2, 3}}, &ctx);
	isEqual({0x0c, 0x02}, AmfByteArray {v8 {4, 5, 6}}, &ctx);
}

TEST(ByteArrayEquality, SimpleValues) {
	AmfByteArray b1(v8 { 1, 2, 3 });
	AmfByteArray b2(v8 { 1, 2, 3 });
	EXPECT_EQ(b1, b2);

	AmfByteArray b3(v8 { 1, 2 });
	EXPECT_NE(b1, b3);
}

TEST(ByteArrayEquality, MixedTypes) {
	AmfByteArray b(v8 { 1, 2, 3 });
	AmfArray a(std::vector<AmfInteger> { 1, 2, 3 });
	EXPECT_NE(b, a);

	AmfVector<int> v { { 1, 2, 3 } };
	EXPECT_NE(b, v);

	AmfVector<unsigned int> uv { { 1, 2, 3 } };
	EXPECT_NE(b, uv);
}

static void deserializesTo(const v8& expected, const v8& data, int left = 0,
	SerializationContext* ctx = nullptr) {
	deserialize(AmfByteArray(expected), data, left, ctx);
}

TEST(ByteArrayDeserialization, Empty) {
	deserializesTo({ }, { 0x0c, 0x01 });
	deserializesTo({ }, { 0x0c, 0x01, 0x01 }, 1);
}

TEST(ByteArrayDeserialization, SimpleValues) {
	deserializesTo({1, 2, 3}, {0x0c, 0x07, 0x01, 0x02, 0x03});
	deserializesTo({1, 2, 3}, {0x0c, 0x07, 0x01, 0x02, 0x03, 0x04}, 1);
	deserializesTo({ 0xff, 0xff, 0xff, 0xff }, {0x0c, 0x09, 0xff, 0xff, 0xff, 0xff});
	deserializesTo({ 0xff, 0xff, 0xff, 0xff }, {0x0c, 0x09, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff}, 3);
}

TEST(ByteArrayDeserialization, MultiByteLengthMarker) {
	v8 values(300, 0xde);
	v8 data = {
		0x0c, 0x84, 0x59,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde,
		0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde
	};
	deserializesTo(values, data);
}

TEST(ByteArrayDeserialization, ObjectReferences) {
	SerializationContext ctx;
	deserializesTo({1, 2, 3}, {0x0c, 0x07, 0x01, 0x02, 0x03}, 0, &ctx);
	deserializesTo({1, 2, 3}, {0x0c, 0x00}, 0, &ctx);
	deserializesTo({4, 5, 6}, {0x0c, 0x07, 0x04, 0x05, 0x06}, 0, &ctx);
	deserializesTo({1, 2, 3}, {0x0c, 0x00}, 0, &ctx);
	deserializesTo({4, 5, 6}, {0x0c, 0x02}, 0, &ctx);
}
