#include "amftest.hpp"

#include "amf.hpp"
#include "types/amfstring.hpp"
#include "types/amfxml.hpp"
#include "types/amfxmldocument.hpp"

TEST(XmlSerialization, EmptyXmlString) {
	AmfXml val;

	v8 expected { 0x0b, 0x01 };
	isEqual(expected, val);

	val = AmfXml("");
	isEqual(expected, val);
}

TEST(XmlSerialization, XmlString) {
	AmfXml val("<asd><foo bar='asd'>qux</foo><boo/></asd>");

	isEqual(v8 {
		0x0b, // AMF_XML
		0x53, // U29X-value, length = 41
    0x3c, 0x61, 0x73, 0x64, 0x3e, 0x3c, 0x66, 0x6f, 0x6f, 0x20, 0x62, 0x61,
    0x72, 0x3d, 0x27, 0x61, 0x73, 0x64, 0x27, 0x3e, 0x71, 0x75, 0x78, 0x3c,
    0x2f, 0x66, 0x6f, 0x6f, 0x3e, 0x3c, 0x62, 0x6f, 0x6f, 0x2f, 0x3e, 0x3c,
    0x2f, 0x61, 0x73, 0x64, 0x3e
	}, val);
}

TEST(XmlSerialization, UnicodeXmlString) {
	AmfXml val("<foo>ħĸð@þæĸſ“ð</foo>");

	isEqual(v8 {
		0x0b,
		0x3f,
		0x3c, 0x66, 0x6f, 0x6f, 0x3e,
		0xc4, 0xa7, 0xc4, 0xb8, 0xc3, 0xb0, 0x40, 0xc3, 0xbe, 0xc3, 0xa6, 0xc4,
		0xb8, 0xc5, 0xbf, 0xe2, 0x80, 0x9c, 0xc3, 0xb0,
		0x3c, 0x2f, 0x66, 0x6f, 0x6f, 0x3e
 }, val);
}

TEST(XmlSerialization, MultiByteLengthString) {
	AmfXml val("<foo>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
		         "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
		         "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
		         "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
		         "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</foo>");

	isEqual(v8 {
		0x0b,
		0x84, 0x6f,
		0x3c, 0x66, 0x6f, 0x6f, 0x3e,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x3c, 0x2f, 0x66, 0x6f, 0x6f, 0x3e
	}, val);
}

TEST(XmlSerialization, SerializationCache) {
	SerializationContext ctx;
	isEqual(v8 { 0x0b, 0x01 }, AmfXml("").serialize(ctx));
	isEqual(v8 { 0x0b, 0x07, 0x66, 0x6f, 0x6f }, AmfXml("foo").serialize(ctx));
	isEqual(v8 { 0x0b, 0x00 }, AmfXml("").serialize(ctx));
	isEqual(v8 { 0x0b, 0x02 }, AmfXml("foo").serialize(ctx));
	isEqual(v8 { 0x0b, 0x07, 0x67, 0x6f, 0x6f }, AmfXml("goo").serialize(ctx));
	isEqual(v8 { 0x0b, 0x00 }, AmfXml("").serialize(ctx));
	isEqual(v8 { 0x0b, 0x02 }, AmfXml("foo").serialize(ctx));
	isEqual(v8 { 0x0b, 0x04 }, AmfXml("goo").serialize(ctx));
}

TEST(XmlSerialization, SerializationCacheNotShared) {
	SerializationContext ctx;
	isEqual(v8 { 0x0b, 0x01 }, AmfXml("").serialize(ctx));
	isEqual(v8 { 0x0b, 0x07, 0x66, 0x6f, 0x6f }, AmfXml("foo").serialize(ctx));
	isEqual(v8 { 0x0b, 0x00 }, AmfXml("").serialize(ctx));
	isEqual(v8 { 0x0b, 0x02 }, AmfXml("foo").serialize(ctx));
	isEqual(v8 { 0x07, 0x07, 0x67, 0x6f, 0x6f }, AmfXmlDocument("goo").serialize(ctx));
	isEqual(v8 { 0x0b, 0x00 }, AmfXml("").serialize(ctx));
	isEqual(v8 { 0x0b, 0x02 }, AmfXml("foo").serialize(ctx));
	isEqual(v8 { 0x0b, 0x07, 0x67, 0x6f, 0x6f }, AmfXml("goo").serialize(ctx));
	isEqual(v8 { 0x06, 0x07, 0x66, 0x6f, 0x6f }, AmfString("foo").serialize(ctx));
	isEqual(v8 { 0x06, 0x07, 0x64, 0x6f, 0x6f }, AmfString("doo").serialize(ctx));
	isEqual(v8 { 0x0b, 0x07, 0x64, 0x6f, 0x6f }, AmfXml("doo").serialize(ctx));
}

TEST(XmlEquality, SimpleValues) {
	AmfXml x1;
	AmfXml x2("");
	EXPECT_EQ(x1, x2);

	AmfXml x3("foo");
	AmfXml x4("foo");
	EXPECT_EQ(x3, x4);

	EXPECT_NE(x1, x3);

	AmfXml x5("foobar");
	EXPECT_NE(x3, x5);
}

TEST(XmlEquality, MixedTypes) {
	AmfXml x1("foo");
	AmfString s("foo");
	AmfXmlDocument x2("foo");
	EXPECT_NE(x1, s);
	EXPECT_NE(x1, x2);
}

static void deserializesTo(const char* expected, const v8& data, int left = 0,
	DeserializationContext* ctx = nullptr) {
	deserialize(AmfXml(expected), data, left, ctx);
}

TEST(XmlDeserialization, SimpleValues) {
	deserializesTo("", v8 { 0x0b, 0x01 });
	deserializesTo("foo", v8 { 0x0b, 0x07, 0x66, 0x6f, 0x6f });
	deserializesTo("foo", v8 { 0x0b, 0x07, 0x66, 0x6f, 0x6f, 0x6f }, 1);
	deserializesTo("<asd><foo bar='asd'>qux</foo><boo/></asd>", v8 {
		0x0b, 0x53, // U29X-value, length = 41
    0x3c, 0x61, 0x73, 0x64, 0x3e, 0x3c, 0x66, 0x6f, 0x6f, 0x20, 0x62, 0x61,
    0x72, 0x3d, 0x27, 0x61, 0x73, 0x64, 0x27, 0x3e, 0x71, 0x75, 0x78, 0x3c,
    0x2f, 0x66, 0x6f, 0x6f, 0x3e, 0x3c, 0x62, 0x6f, 0x6f, 0x2f, 0x3e, 0x3c,
    0x2f, 0x61, 0x73, 0x64, 0x3e
	});
}

TEST(XmlDeserialization, UnicodeXmlString) {
	deserializesTo("<foo>ħĸð@þæĸſ“ð</foo>", v8 {
		0x0b, 0x3f,
		0x3c, 0x66, 0x6f, 0x6f, 0x3e,
		0xc4, 0xa7, 0xc4, 0xb8, 0xc3, 0xb0, 0x40, 0xc3, 0xbe, 0xc3, 0xa6, 0xc4,
		0xb8, 0xc5, 0xbf, 0xe2, 0x80, 0x9c, 0xc3, 0xb0,
		0x3c, 0x2f, 0x66, 0x6f, 0x6f, 0x3e
	});
}

TEST(XmlDeserialization, MultiByteLengthString) {
	std::string val(
		"<foo>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
		"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
		"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
		"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
		"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</foo>");

	v8 data {
		0x0b, 0x84, 0x6f,
		0x3c, 0x66, 0x6f, 0x6f, 0x3e,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x3c, 0x2f, 0x66, 0x6f, 0x6f, 0x3e,
		0xff // extra byte
	};

	deserializesTo(val.c_str(), data, 1);
}

TEST(XmlDeserialization, ObjectReference) {
	DeserializationContext ctx;
	deserializesTo("foo", v8 { 0x0b, 0x07, 0x66, 0x6f, 0x6f }, 0, &ctx);
	deserializesTo("foo", v8 { 0x0b, 0x07, 0x66, 0x6f, 0x6f, 0x6f }, 1, &ctx);
	deserializesTo("foo", v8 { 0x0b, 0x00 }, 0, &ctx);
	deserializesTo("foo", v8 { 0x0b, 0x02 }, 0, &ctx);
	deserializesTo("bar", v8 { 0x0b, 0x07, 0x62, 0x61, 0x72 }, 0, &ctx);
	deserializesTo("foo", v8 { 0x0b, 0x02 }, 0, &ctx);
	deserializesTo("bar", v8 { 0x0b, 0x04 }, 0, &ctx);
}
